###Visitor (Посетитель) 
Это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы
 объектов, над которыми эти операции могут выполняться.
<br></br>

#####Проблема
Ваша команда разрабатывает приложение, работающее с геоданными в виде графа. Узлами графа являются городские локации: 
памятники, театры, рестораны, важные предприятия и прочее. Каждый узел имеет ссылки на другие, ближайшие к нему узлы. 
Каждому типу узлов соответствует свой класс, а каждый узел представлен отдельным объектом.

![problem](../../../../../resources/visitor/visitor_1.png)

Ваша задача — сделать экспорт этого графа в XML. Дело было бы плёвым, если бы вы могли редактировать классы узлов. 
Достаточно было бы добавить метод экспорта в каждый тип узла, а затем, перебирая узлы графа, вызывать этот метод для 
каждого узла. Благодаря полиморфизму, решение получилось бы изящным, так как вам не пришлось бы привязываться к 
конкретным классам узлов.

![problem](../../../../../resources/visitor/visitor_2.png)

К тому же он сомневался в том, что экспорт в XML вообще уместен в рамках этих классов. Их основная задача была связана 
с геоданными, а экспорт выглядит в рамках этих классов чужеродно.

Была и ещё одна причина запрета. Если на следующей неделе вам бы понадобился экспорт в какой-то другой формат данных, 
то эти классы снова пришлось бы менять.

<br></br>

#####Решение
Паттерн Посетитель предлагает разместить новое поведение в отдельном классе, вместо того чтобы множить его сразу в 
нескольких классах. Объекты, с которыми должно было быть связано поведение, не будут выполнять его самостоятельно. 
Вместо этого вы будете передавать эти объекты в методы посетителя.

Код поведения, скорее всего, должен отличаться для объектов разных классов, поэтому и методов у посетителя должно быть 
несколько. Названия и принцип действия этих методов будет схож, но основное отличие будет в типе принимаемого в 
параметрах объекта, например:
```
class ExportVisitor implements Visitor is
    method doForCity(City c) { ... }
    method doForIndustry(Industry f) { ... }
    method doForSightSeeing(SightSeeing ss) { ... }
    // ...
```
Здесь возникает вопрос: как подавать узлы в объект-посетитель? Так как все методы имеют отличающуюся сигнатуру, 
использовать полиморфизм при переборе узлов не получится. Придётся проверять тип узлов для того, чтобы выбрать
 соответствующий метод посетителя.
 ```
foreach (Node node in graph)
    if (node instanceof City)
        exportVisitor.doForCity((City) node)
    if (node instanceof Industry)
        exportVisitor.doForIndustry((Industry) node)
    // ...
 ```

Тут не поможет даже механизм перегрузки методов (доступный в Java и C#). Если назвать все методы одинаково, то 
неопределённость реального типа узла всё равно не даст вызвать правильный метод. Механизм перегрузки всё время будет 
вызывать метод посетителя, соответствующий типу Node, а не реального класса поданного узла.

Но паттерн Посетитель решает и эту проблему, используя механизм двойной диспетчеризации. Вместо того, чтобы самим искать 
нужный метод, мы можем поручить это объектам, которые передаём в параметрах посетителю. А они уже вызовут правильный 
метод посетителя.

 ```
// Client code
foreach (Node node in graph)
    node.accept(exportVisitor)

// City
class City is
    method accept(Visitor v) is
        v.doForCity(this)
    // ...

// Industry
class Industry is
    method accept(Visitor v) is
        v.doForIndustry(this)
    // ...
 ```

Как видите, изменить классы узлов всё-таки придётся. Но это простое изменение позволит применять к объектам узлов и 
другие поведения, ведь классы узлов будут привязаны не к конкретному классу посетителей, а к их общему интерфейсу. 
Поэтому если придётся добавить в программу новое поведение, вы создадите новый класс посетителей и будете передавать 
его в методы узлов.